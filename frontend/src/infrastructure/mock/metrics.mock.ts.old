/**
 * Mock Data Generator for Real-time Metrics
 * Generates realistic EMS data with physics-based simulations
 */

import { RealtimeMetrics } from '@/domain/entities/metrics.entity';
import { timeEngine } from '@/infrastructure/time/time-engine';
import { TimeSeriesStore } from '@/infrastructure/time/time-series-store';
import { AggregationMethod } from '@/domain/entities/time-series.entity';
import { WeatherSimulator } from '@/infrastructure/simulation/weather-simulator';
import { SolarSimulator } from '@/infrastructure/simulation/solar-simulator';
import { LoadSimulator } from '@/infrastructure/simulation/load-simulator';
import { BatteryController } from '@/infrastructure/simulation/battery-controller';
import { DEFAULT_SITE_CONFIG } from '@/infrastructure/simulation/simulation-config';

/**
 * Base configuration for realistic data generation
 */
const CONFIG = {
  solar: {
    maxPower: 500,        // kW
    peakHour: 12,         // noon
    dawnHour: 6,
    duskHour: 18,
  },
  consumption: {
    baseLoad: 180,        // kW (always-on baseline)
    peakLoad: 400,        // kW
    hvacRatio: 0.4,       // 40% of consumption
    lightingRatio: 0.25,  // 25%
    equipmentRatio: 0.25, // 25%
    otherRatio: 0.1,      // 10%
  },
  storage: {
    capacity: 1000,       // kWh
    maxPower: 250,        // kW
    minSoc: 20,           // %
    maxSoc: 95,           // %
    efficiency: 0.95,     // 95% round-trip efficiency
  },
  grid: {
    voltage: 400,         // V
    frequency: 50,        // Hz
  },
};

/**
 * Smoothing class to prevent sudden jumps
 */
class ValueSmoother {
  private previousValue: number = 0;
  private smoothingFactor: number;

  constructor(smoothingFactor: number = 0.3) {
    this.smoothingFactor = smoothingFactor;
  }

  smooth(newValue: number): number {
    this.previousValue = this.previousValue * (1 - this.smoothingFactor) + newValue * this.smoothingFactor;
    return this.previousValue;
  }

  reset(value: number): void {
    this.previousValue = value;
  }
}

/**
 * Generate solar power based on time of day with realistic cloud patterns
 */
function generateSolarPower(hour: number, minute: number, cloudState: { coverage: number; lastChange: number }): number {
  const { maxPower, peakHour, dawnHour, duskHour } = CONFIG.solar;
  
  // No generation at night
  if (hour < dawnHour || hour >= duskHour) {
    return 0;
  }
  
  // Calculate sun position (0 to 1, peak at noon)
  const dayProgress = (hour + minute / 60 - dawnHour) / (duskHour - dawnHour);
  const sunAngle = Math.sin(dayProgress * Math.PI);
  
  // Base solar power from sun position
  let solarPower = sunAngle * maxPower;
  
  // Simulate cloud coverage (changes slowly over time)
  cloudState.lastChange++;
  if (cloudState.lastChange > 20 || Math.random() > 0.95) {
    // Cloud state changes slowly
    const targetCoverage = Math.random() > 0.7 ? 0.2 + Math.random() * 0.3 : 0.9 + Math.random() * 0.1;
    cloudState.coverage = cloudState.coverage * 0.9 + targetCoverage * 0.1;
    cloudState.lastChange = 0;
  }
  
  solarPower *= cloudState.coverage;
  
  // Add very small random variations (sensor noise)
  solarPower *= 0.98 + Math.random() * 0.04;
  
  return Math.max(0, solarPower);
}

/**
 * Generate consumption with realistic daily patterns
 */
function generateConsumption(hour: number, minute: number, dayOfWeek: number): number {
  const { baseLoad, peakLoad } = CONFIG.consumption;
  
  // Weekend has lower consumption
  const isWeekend = dayOfWeek === 0 || dayOfWeek === 6;
  const weekendFactor = isWeekend ? 0.7 : 1.0;
  
  // Business hours (8-18) with smooth transitions
  let hourlyFactor: number;
  
  if (hour < 6) {
    // Night: minimal consumption
    hourlyFactor = 0.3;
  } else if (hour < 8) {
    // Morning ramp-up (6-8)
    hourlyFactor = 0.3 + (hour - 6 + minute / 60) * 0.25; // 0.3 to 0.8
  } else if (hour < 12) {
    // Morning peak (8-12)
    hourlyFactor = 0.8 + (hour - 8 + minute / 60) * 0.05; // 0.8 to 1.0
  } else if (hour < 14) {
    // Lunch dip (12-14)
    hourlyFactor = 1.0 - (hour - 12 + minute / 60) * 0.15; // 1.0 to 0.7
  } else if (hour < 17) {
    // Afternoon peak (14-17)
    hourlyFactor = 0.7 + (hour - 14 + minute / 60) * 0.1; // 0.7 to 1.0
  } else if (hour < 20) {
    // Evening decline (17-20)
    hourlyFactor = 1.0 - (hour - 17 + minute / 60) * 0.2; // 1.0 to 0.4
  } else {
    // Night
    hourlyFactor = 0.4 - (hour - 20 + minute / 60) * 0.025; // 0.4 to 0.3
  }
  
  // Apply patterns
  const load = baseLoad + (peakLoad - baseLoad) * hourlyFactor * weekendFactor;
  
  // Add small random variations (equipment cycling)
  const variation = 0.97 + Math.random() * 0.06;
  
  return load * variation;
}

/**
 * Calculate storage power with smooth state transitions
 */
function calculateStoragePower(
  solar: number,
  consumption: number,
  currentSoc: number,
  previousStoragePower: number
): { power: number; newSoc: number } {
  const { capacity, maxPower, minSoc, maxSoc, efficiency } = CONFIG.storage;
  
  const energyBalance = solar - consumption;
  let targetPower = 0;
  
  if (energyBalance > 10 && currentSoc < maxSoc - 2) {
    // Surplus energy - charge battery (with efficiency loss)
    const availableCharge = (maxSoc - currentSoc) * capacity / 100;
    targetPower = Math.min(energyBalance * 0.9, maxPower, availableCharge * 30); // 30 = 1/120th of hour in 2s updates
  } else if (energyBalance < -10 && currentSoc > minSoc + 2) {
    // Deficit - discharge battery (with efficiency consideration)
    const availableDischarge = (currentSoc - minSoc) * capacity / 100;
    targetPower = Math.max(energyBalance * 0.9, -maxPower, -availableDischarge * 30);
  } else if (Math.abs(energyBalance) <= 10) {
    // Near balance - gradually reduce storage power
    targetPower = previousStoragePower * 0.8;
  }
  
  // Smooth transition (prevent sudden changes)
  const storagePower = previousStoragePower * 0.7 + targetPower * 0.3;
  
  // Calculate SOC change (2 second interval = 1/1800 of an hour)
  const socChange = (storagePower / capacity) * (2 / 3600) * 100;
  const newSoc = Math.max(minSoc, Math.min(maxSoc, currentSoc + socChange));
  
  return { power: storagePower, newSoc };
}

/**
 * Calculate grid power (balance after solar and storage)
 */
function calculateGridPower(solar: number, consumption: number, storage: number): number {
  return consumption - solar - storage;
}

/**
 * Calculate efficiency metrics
 */
function calculateEfficiencyMetrics(
  solar: number,
  consumption: number,
  grid: number,
  storage: number
): { autarchy: number; selfConsumption: number } {
  let autarchy = 0;
  let selfConsumption = 0;
  
  // Autarchy: percentage of consumption met by local generation (not from grid)
  if (consumption > 1) {
    const gridImport = Math.max(0, grid);
    autarchy = Math.max(0, Math.min(100, ((consumption - gridImport) / consumption) * 100));
  }
  
  // Self-consumption: percentage of solar power used locally (not exported to grid)
  if (solar > 0.1) {
    const gridExport = Math.max(0, -grid);
    selfConsumption = Math.max(0, Math.min(100, ((solar - gridExport) / solar) * 100));
  }
  
  return { autarchy, selfConsumption };
}

/**
 * Main mock data generator with state persistence and time-series storage
 */
export class MockMetricsGenerator {
  private currentSoc: number = 65;
  private lastTimestamp: number;
  private previousStoragePower: number = 0;
  private cloudState = { coverage: 1.0, lastChange: 0 };
  private lastValidSelfConsumption: number = 0; // Track last daytime self-consumption
  
  // Smoothers for each metric
  private solarSmoother = new ValueSmoother(0.2);
  private consumptionSmoother = new ValueSmoother(0.15);
  private gridSmoother = new ValueSmoother(0.25);
  
  // Time-series stores for historical data
  private solarStore: TimeSeriesStore<number>;
  private consumptionStore: TimeSeriesStore<number>;
  private gridStore: TimeSeriesStore<number>;
  private storageStore: TimeSeriesStore<number>;
  private socStore: TimeSeriesStore<number>;
  
  // Time engine subscription
  private unsubscribe: (() => void) | null = null;

  constructor() {
    this.lastTimestamp = timeEngine.getCurrentTime();
    
    // Initialize time-series stores with 7-day retention
    const storeConfig = {
      maxPoints: 10000,
      retentionMs: 7 * 24 * 60 * 60 * 1000, // 7 days
      aggregationMethod: AggregationMethod.AVERAGE,
    };
    
    this.solarStore = new TimeSeriesStore(storeConfig);
    this.consumptionStore = new TimeSeriesStore(storeConfig);
    this.gridStore = new TimeSeriesStore(storeConfig);
    this.storageStore = new TimeSeriesStore(storeConfig);
    this.socStore = new TimeSeriesStore(storeConfig);
    
    // Subscribe to time engine updates
    this.subscribeToTimeEngine();
  }
  
  /**
   * Subscribe to time engine for automatic updates
   */
  private subscribeToTimeEngine(): void {
    this.unsubscribe = timeEngine.subscribe((currentTime) => {
      // Store historical data point whenever time advances
      this.lastTimestamp = currentTime;
    });
  }
  
  /**
   * Unsubscribe from time engine (cleanup)
   */
  public dispose(): void {
    if (this.unsubscribe) {
      this.unsubscribe();
      this.unsubscribe = null;
    }
  }
  
  /**
   * Generate realistic real-time metrics
   */
  generateMetrics(): RealtimeMetrics {
    // Use time engine instead of Date.now()
    const currentTime = timeEngine.getCurrentTime();
    const now = new Date(currentTime);
    const hour = now.getHours();
    const minute = now.getMinutes();
    const dayOfWeek = now.getDay();
    
    // Generate base values with smoothing
    const rawSolar = generateSolarPower(hour, minute, this.cloudState);
    const solarPower = this.solarSmoother.smooth(rawSolar);
    
    const rawConsumption = generateConsumption(hour, minute, dayOfWeek);
    const consumptionPower = this.consumptionSmoother.smooth(rawConsumption);
    
    // Calculate storage with smooth transitions
    const { power: storagePower, newSoc } = calculateStoragePower(
      solarPower,
      consumptionPower,
      this.currentSoc,
      this.previousStoragePower
    );
    this.currentSoc = newSoc;
    this.previousStoragePower = storagePower;
    
    // Calculate grid
    const rawGrid = calculateGridPower(solarPower, consumptionPower, storagePower);
    const gridPower = this.gridSmoother.smooth(rawGrid);
    
    // Calculate efficiency
    const { autarchy, selfConsumption } = calculateEfficiencyMetrics(
      solarPower,
      consumptionPower,
      gridPower,
      storagePower
    );
    
    // Keep last valid self-consumption during nighttime
    if (selfConsumption > 0) {
      this.lastValidSelfConsumption = selfConsumption;
    }
    const displaySelfConsumption = solarPower > 0.1 ? selfConsumption : this.lastValidSelfConsumption;
    
    // Breakdown consumption
    const { hvacRatio, lightingRatio, equipmentRatio, otherRatio } = CONFIG.consumption;
    
    // Store historical data points
    this.solarStore.addPoint({ timestamp: currentTime, value: solarPower });
    this.consumptionStore.addPoint({ timestamp: currentTime, value: consumptionPower });
    this.gridStore.addPoint({ timestamp: currentTime, value: gridPower });
    this.storageStore.addPoint({ timestamp: currentTime, value: storagePower });
    this.socStore.addPoint({ timestamp: currentTime, value: this.currentSoc });
    
    return {
      timestamp: now,
      grid: {
        activePower: gridPower,
        voltage: CONFIG.grid.voltage + (Math.random() - 0.5) * 5,
        frequency: CONFIG.grid.frequency + (Math.random() - 0.5) * 0.1,
      },
      solar: {
        activePower: solarPower,
        dailyYield: this.calculateDailyYield(hour, minute),
        efficiency: solarPower > 0 ? 88 + Math.random() * 7 : 0,
        irradiance: solarPower > 0 ? (solarPower / CONFIG.solar.maxPower) * 1000 : 0,
      },
      consumption: {
        activePower: consumptionPower,
        breakdown: {
          hvac: consumptionPower * hvacRatio * (0.95 + Math.random() * 0.1),
          lighting: consumptionPower * lightingRatio * (0.95 + Math.random() * 0.1),
          equipment: consumptionPower * equipmentRatio * (0.95 + Math.random() * 0.1),
          other: consumptionPower * otherRatio * (0.95 + Math.random() * 0.1),
        },
      },
      storage: {
        activePower: storagePower,
        soc: this.currentSoc,
        capacity: CONFIG.storage.capacity,
        temperature: 22 + (Math.abs(storagePower) / CONFIG.storage.maxPower) * 8 + Math.random() * 2,
        voltage: 800 + (this.currentSoc - 50) * 2 + Math.random() * 10,
        current: Math.abs(storagePower) / 0.82,
      },
      calculated: {
        autarchy,
        selfConsumption: displaySelfConsumption,
        netEnergy: -gridPower,
      },
    };
  }
  
  /**
   * Get historical data for a specific metric
   */
  getHistoricalData(
    metric: 'solar' | 'consumption' | 'grid' | 'storage' | 'soc',
    startTime: number,
    endTime: number,
    maxPoints?: number
  ) {
    const store = this.getStore(metric);
    return store.query({
      range: { start: startTime, end: endTime },
      maxPoints,
      aggregation: AggregationMethod.AVERAGE,
    });
  }
  
  /**
   * Get the appropriate store for a metric
   */
  private getStore(metric: 'solar' | 'consumption' | 'grid' | 'storage' | 'soc'): TimeSeriesStore<number> {
    switch (metric) {
      case 'solar':
        return this.solarStore;
      case 'consumption':
        return this.consumptionStore;
      case 'grid':
        return this.gridStore;
      case 'storage':
        return this.storageStore;
      case 'soc':
        return this.socStore;
    }
  }
  
  /**
   * Get statistics for all stores
   */
  getStorageStats() {
    return {
      solar: this.solarStore.getStats(),
      consumption: this.consumptionStore.getStats(),
      grid: this.gridStore.getStats(),
      storage: this.storageStore.getStats(),
      soc: this.socStore.getStats(),
    };
  }
  
  /**
   * Calculate accumulated daily solar yield
   */
  private calculateDailyYield(hour: number, minute: number): number {
    const { dawnHour, duskHour, maxPower } = CONFIG.solar;
    if (hour < dawnHour) return 0;
    
    const hoursElapsed = Math.min(hour - dawnHour + minute / 60, duskHour - dawnHour);
    
    // Integrate sine wave from dawn to current time
    const avgGeneration = maxPower * (2 / Math.PI) * this.cloudState.coverage * 0.7;
    
    return avgGeneration * hoursElapsed;
  }
  
  /**
   * Reset SOC to a specific value
   */
  resetSoc(soc: number): void {
    this.currentSoc = Math.max(CONFIG.storage.minSoc, Math.min(CONFIG.storage.maxSoc, soc));
  }
}

/**
 * Singleton instance
 */
export const mockMetricsGenerator = new MockMetricsGenerator();
